{
  "name": "orchestrate",
  "version": "0.0.8",
  "main": "index",
  "tags": [
    "orchestrate",
    "driver"
  ],
  "dependencies": {
    "request": "~2.27.0",
    "kew": "~0.2.2",
    "parse-link-header": "~0.1.0"
  },
  "devDependencies": {
    "mocha": "*",
    "expect.js": "0.1.x",
    "nock": "*"
  },
  "scripts": {
    "test": "make test"
  },
  "readme": "# orchestrate.js [![Build Status](https://travis-ci.org/Bowery/orchestrate.js.png)](https://travis-ci.org/Bowery/orchestrate.js)\n\nNode Driver for [Orchestrate.io](http://orchestrate.io).\n\n\n# Installation\n\n```\n$ npm install orchestrate\n```\n\n# Running Tests\nCurrently, Orchestrate.js runs against the actual Orchestrate API. At the moment, there is no available local version to work with.\n\nEnsure all dependencies are installed within the orchestrate director by running\n\n```\n$ npm install\n```\nTo run tests:\n\n```\n$ npm test\n```\n\n# Creating a Client\n\n```javascript\nvar db = require('orchestrate')(token)\n```\n\n# Running Queries\n\nOrchestrate comes with support for GET/PUT/DEL for key-value queries, as well as search, graph, and events. Documentation can be found [here](https://docs.orchestrate.io/).\n\nAll queries are promise based. Just as a typical function would return a callback containing an error field followed by a result, orchestrate.js returns `then` and `fail` methods.\n\n## Key-Value\n\nTo get a value:\n\n```javascript\ndb.get('collection', 'key')\n.then(function (result) {\n\n})\n.fail(function (err) {\n\n})\n```\n\nTo set a value:\n\n```javascript\ndb.put('collection', 'key', {\n  \"name\": \"Steve Kaliski\",\n  \"hometown\": \"New York, NY\",\n  \"twitter\": \"@stevekaliski\"\n})\n.then(function (result) {\n\n})\n.fail(function (err) {\n\n})\n```\n\nOrchestrate also supports [conditional put statements](https://docs.orchestrate.io/#put-(create/update)) that determines whether or not the store operation will occur. `db.put` takes a fourth argument `match` which is either the `ref` value or `false`. If a ref value is provided an `update` will occur if there is a valid match, if false is provided, a `create` will occur if there is no match.\n\n```javascript\ndb.put('collection', 'key', data, 'cbb48f9464612f20') // update\ndb.put('collection', 'key', data, false) // create\n```\n\nTo remove a value:\n\n```javascript\ndb.remove('collection', 'key', true)\n.then(function (result) {\n  \n})\n.fail(function (err) {\n  \n})\n```\n\nThe last parameter is optional. If supplied the ref history will be removed as well.\n\n## Search\n\nTo run a quick search, you can simply provide the collection you'd like to search within, and your query. Orchestrate supports any type of query including lucene queries.\n\n```javascript\ndb.search('collection', 'query')\n.then(function (result) {\n\n})\n.fail(function (err) {\n\n})\n```\n\nIf you want to include a limit or offset, the more verbose `SearchBuilder` is available:\n\n```javascript\ndb.newSearchBuilder()\n.collection('users')\n.limit(100)\n.offset(10)\n.query('steve')\n```\n\n## Graphs\nAn awesome feature Orchestrate includes is the ability to generate graphs between collections. For example, consider the collections `users` and `movies`. Some user Steve will `like` a variety of movies. We can generate this relationship:\n\n```javascript\ndb.newGraphBuilder()\n.create()\n.from('users', 'Steve')\n.related('likes')\n.to('movies', 'Superbad')\n```\n\nWe can then look up all the different items Steve likes:\n```javascript\ndb.newGraphReader()\n.get()\n.from('users', 'Steve')\n.related('likes')\n```\n\nWe can even take this another step further:\n```javascript\ndb.newGraphReader()\n.get()\n.from('users', 'Steve')\n.related('friends', 'likes')\n```\nThis will return all of the things that friends of Steve have liked. This assumes a friend relation has previously been defined between Steve and another user.\n\nIf we want to delete a graph relationship:\n```javascript\ndb.newGraphBuilder()\n.remove()\n.from('users', 'Steve')\n.related('likes')\n.to('movies', 'Superbad')\n```\n\n## Events\nEvents are time-ordered objects that exist with the context of a Key-Value object. Consider comments on a post or messages in a thread.\n\nCreating an event:\n```javascript\ndb.newEventBuilder()\n.from('users', 'Steve')\n.type('update')\n.data({\"text\": \"Hello!\"})\n```\n\nGetting events:\n```javascript\ndb.newEventReader()\n.from('users', 'Steve')\n.start(1384534722568)\n.end(1384535726540)\n.type('update')\n```\n\n## Removing a Collection\n\n```javascript\ndb.deleteCollection('users')\n```\n\n",
  "readmeFilename": "README.md",
  "description": "Node Driver for [Orchestrate.io](http://orchestrate.io).",
  "_id": "orchestrate@0.0.8",
  "dist": {
    "shasum": "d78c1392756e4700f48d2e76a852c6d3e5037c8c"
  },
  "_from": "orchestrate@",
  "_resolved": "https://registry.npmjs.org/orchestrate/-/orchestrate-0.0.8.tgz"
}
